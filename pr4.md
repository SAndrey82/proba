**Отладка**

В Git есть несколько команд, используемых для нахождения проблем в коде. Это команды для поиска места в истории, где проблема впервые проявилась и собственно виновника этой проблемы.

[**git bisect**](https://git-scm.com/docs/git-bisect)

Команда ***git bisect*** — это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

[**git blame**](https://git-scm.com/docs/git-blame)

Команда ***git blame*** выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

[**git grep**](https://git-scm.com/docs/git-grep)

Команда ***git grep*** используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.

**Внесение исправлений**

Некоторые команды в Git основываются на подходе к рассмотрению коммитов в терминах внесённых ими изменений, т. е. рассматривают историю коммитов как цепочку патчей. Ниже перечислены эти команды.

[**git cherry-pick**](https://git-scm.com/docs/git-cherry-pick)

Команда ***git cherry-pick*** берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесёнными в неё изменениями.

[**git rebase**](https://git-scm.com/docs/git-rebase)

***git rebase*** — это «автоматизированный» ***cherry-pick***. Он выполняет ту же работу, но для цепочки коммитов, тем самым как бы перенося ветку на новое место.

[**git revert**](https://git-scm.com/docs/git-revert)

Команда ***git revert*** — полная противоположность ***git cherry-pick***. Она создаёт новый коммит, который вносит изменения, противоположные указанному коммиту, по существу отменяя его.

**Работа с помощью электронной почты**

Множество проектов, использующих Git (включая сам Git), активно используют списки рассылок для координирования процесса разработки. В Git есть несколько команд, помогающих в этом, начиная от генерации патчей, готовых к пересылке по электронной почте, заканчивая применением таких патчей прямиком из почты.

[**git apply**](https://git-scm.com/docs/git-apply)

Команда ***git apply*** применяет патч, сформированный с помощью команды ***git diff*** или ***GNU diff***. Она делает практически то же самое, что и команда patch.

[**git am**](https://git-scm.com/docs/git-am)

Команда ***git am*** используется для применения патчей из входящих сообщений электронной почты, в частности, тех что используют формат mbox. Это используется для простого получения изменений через email и применения их к проекту.

[**git format-patch**](https://git-scm.com/docs/git-format-patch)

Команда ***git format-patch*** используется для создания набора патчей в формате mbox которые можно использовать для отправки в список рассылки.

[**git send-email**](https://git-scm.com/docs/git-send-email)

Команда ***git send-email*** используется для отсылки патчей, сформированных с использованием ***git format-patch***, по электронной почте.

[**git request-pull**](https://git-scm.com/docs/git-request-pull)

Команда ***git request-pull*** используется для генерации примерного текста сообщения для отсылки кому-либо. Если у вас есть ветка, хранящаяся на публичном сервере, и вы хотите чтобы кто-либо забрал эти изменения без возни с отсылкой патчей по электронной почте, вы можете выполнить эту команду и послать её вывод тому человеку.

**Внешние системы**

В Git есть несколько стандартных команд для работы с другими системами контроля версий.

[**git svn**](https://git-scm.com/docs/git-svn)

Команда ***git svn*** используется для работы с сервером Subversion. Это означает, что вы можете использовать Git в качестве SVN клиента, забирать изменения и отправлять свои собственные на сервер Subversion.

[**git fast-import**](https://git-scm.com/docs/git-fast-imort)

Для других систем контроля версий, либо для импорта произвольно форматированных данных, вы можете использовать ***git fast-import***, которая умеет преобразовывать данные в формат, понятный Git.

**Администрирование**

Если вы администрируете Git репозиторий или вам нужно исправить что-либо, Git предоставляет несколько административных команд вам в помощь.

[**git gc**](https://git-scm.com/docs/git-gc)

Команда ***git gc*** запускает сборщик мусора в вашем репозитории, который удаляет ненужные файлы из хранилища объектов и эффективно упаковывает оставшиеся файлы.

[**git fsck**](https://git-scm.com/docs/git-fsck)

Команда ***git fsck*** используется для проверки внутgiренней базы данных на предмет наличия ошибок и несоответствий.

[**git reflog**](https://git-scm.com/docs/git-reflog)

Команда ***git reflog*** просматривает историю изменения голов веток на протяжении вашей работы для поиска коммитов, которые вы могли внезапно потерять, переписывая историю.

[**git filter-branch**](https://git-scm.com/docs/git-filter-branch)

Команда ***git filter-branch*** используется для переписывания содержимого коммитов по заданному алгоритму, например, для полного удаления файла из истории или для вычленения истории лишь части файлов в проекте для вынесения в отдельный репозиторий.